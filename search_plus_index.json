{"./":{"url":"./","title":"关于","keywords":"","body":"准备写点东西 从数据结构开始吧 如何发布自己的书 By zhjzjnb，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-06-13 11:35:59 "},"c-struct/LinkedList.html":{"url":"c-struct/LinkedList.html","title":"1-单链表","keywords":"","body":"链表是一种感官上连续,但是内存不连续的存储结构,因为使用malloc动态分配的内存在堆上. data \\ next-> data \\ next-> NULL 头部插入,新节点的next指向头指针,头指针指向新节点 尾部插入,直接遍历到尾部,插入新节点,速度慢 头部插入时间复杂度O(1),尾部插入时间复杂度O(n) 查找时间复杂福O(n) // Copyright © 2019 zhjzjnb. All rights reserved. #include #include #include #include //开启 使用头插入,否则尾插入 //#define HEAD_INSERT typedef int Data; typedef struct Node{ Data data; struct Node *next; }Node; typedef struct LinkedList{ Node *head; int len; }LinkedList; //创建一个表头 LinkedList *create(){ LinkedList *linkedList = malloc(sizeof(LinkedList)); linkedList->head = NULL; linkedList->len = 0; return linkedList; } //向表尾部插入一个节点 void insertTail(LinkedList *linkedList, Node *node){ assert(linkedList!=NULL); assert(node!=NULL); node->next = NULL; Node *head = linkedList->head; linkedList->len++; if (head==NULL) { linkedList->head = node; }else{ while (head->next) { head = head->next; } head->next = node; } } //向表头部插入一个节点 void insertHead(LinkedList *linkedList, Node *node){ assert(linkedList!=NULL); assert(node!=NULL); Node *head = linkedList->head; linkedList->len++; if (head==NULL) { linkedList->head = node; node->next = NULL; }else{ node->next = head; linkedList->head = node; } } //根据数据查找一个节点 Node *find(LinkedList *linkedList, Data data){ assert(linkedList!=NULL); assert(linkedList->len>0); Node *head = linkedList->head; while (head) { if (head->data==data) { return head; } head = head->next; } return NULL; } //根据数据删除一个节点 Node *delete(LinkedList *linkedList, Data data){ assert(linkedList!=NULL); assert(linkedList->len>0); Node *head = linkedList->head; Node *tmp = head; while (head) { if (head->data==data) { linkedList->len--; if (tmp==head) { linkedList->head = tmp->next; return tmp; } tmp->next = head->next; return head; } tmp = head; head = head->next; } return NULL; } // 清理链表 void cleanup(LinkedList **linkedList){ assert(*linkedList!=NULL); Node *head = (*linkedList)->head; Node *tmp; while (head) { tmp = head; head = head->next; // printf(\"free data:%d\\n\",tmp->data); free(tmp); } (*linkedList)->head = NULL; (*linkedList)->len = 0; *linkedList = NULL; free(*linkedList); } // 打印链表 void dump(LinkedList *linkedList){ assert(linkedList!=NULL); if (linkedList->lenhead; printf(\"dump begin\\n\"); while (head) { printf(\"%d \",head->data); head = head->next; } printf(\"\\ndump end\\n\"); } int main(int argc, const char * argv[]) { LinkedList *linkedList = create(); for (int i=0; idata = i; #ifdef HEAD_INSERT insertHead(linkedList,node); #else insertTail(linkedList,node); #endif } dump(linkedList); if(find(linkedList,3)){ printf(\"find success data:3\\n\"); } if(find(linkedList,21)){ printf(\"find success data:21\\n\"); } Node *node = delete(linkedList,4); if (node) { printf(\"delete success len:%d\\n\",linkedList->len); free(node); }else{ printf(\"delete fail\\n\"); } dump(linkedList); cleanup(&linkedList); return 0; } By zhjzjnb，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-06-13 11:35:59 "},"c-struct/Stack.html":{"url":"c-struct/Stack.html","title":"2-栈","keywords":"","body":"栈是一种先进后出的数据类型,只能操作栈顶,使用链表的头插法可以很快写出栈 输入:1-2-3-4 输出:4-3-2-1 // Copyright © 2019 zhjzjnb. All rights reserved. #include #include #include #include typedef int Data; typedef struct Node{ Data data; struct Node *next; }Node; typedef struct Stack{ Node *head; int top; }Stack; //创建一个空栈 Stack *create(){ Stack *stack = malloc(sizeof(Stack)); stack->head = NULL; stack->top = 0; return stack; } //向栈顶压入数据 void push(Stack *stack, Node *node){ assert(stack!=NULL); assert(node!=NULL); Node *head = stack->head; stack->top++; if (head==NULL) { stack->head = node; node->next = NULL; }else{ node->next = head; stack->head = node; } } //从栈顶弹出数据 Node *pop(Stack *stack){ assert(stack!=NULL); if (stack->top==0) { return NULL; } stack->top--; Node *head = stack->head; stack->head = head->next; return head; } // 清理栈 void cleanup(Stack **stack){ assert(*stack!=NULL); Node *head = (*stack)->head; Node *tmp; while (head) { tmp = head; head = head->next; // printf(\"free data:%d\\n\",tmp->data); free(tmp); } (*stack)->head = NULL; (*stack)->top = 0; *stack = NULL; free(*stack); } // 打印栈 void dump(Stack *stack){ assert(stack!=NULL); if (stack->tophead; printf(\"dump begin\\n\"); while (head) { printf(\"%d \",head->data); head = head->next; } printf(\"\\ndump end\\n\"); } int main(int argc, const char * argv[]) { Stack *stack = create(); for (int i=0; idata = i; push(stack,node); } dump(stack); Node *node = pop(stack); if(node){ printf(\"pop success data:%d\\n\",node->data); free(node); }else{ printf(\"pop failed\\n\"); } dump(stack); cleanup(&stack); return 0; } By zhjzjnb，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-06-13 11:35:59 "},"c-struct/Queue.html":{"url":"c-struct/Queue.html","title":"3-队列","keywords":"","body":"队列是一种先进先出的数据类型,需要一个尾指针辅助 入队示意图,head始终指向队列头,将tail->next指向新节点,然后tail指向新节点 输入:1-2-3-4 输出:1-2-3-4 // Copyright © 2019 zhjzjnb. All rights reserved. #include #include #include #include typedef int Data; typedef struct Node{ Data data; struct Node *next; }Node; typedef struct Queue{ Node *head; Node *tail; int size; }Queue; //创建队列 Queue *create(){ Queue *queue = malloc(sizeof(Queue)); queue->head = NULL; queue->tail = NULL; queue->size = 0; return queue; } //进入队列 void enqueue(Queue *queue, Node *node){ assert(queue!=NULL); assert(node!=NULL); Node *head = queue->head; queue->size++; node->next = NULL; if (head==NULL) { queue->head = node; queue->tail = node; }else{ queue->tail->next = node; queue->tail = node; } } //数据出队 Node *dequeue(Queue *queue){ assert(queue!=NULL); if (queue->size==0) { return NULL; } queue->size--; Node *head = queue->head; queue->head = head->next; return head; } // 清理 void cleanup(Queue **queue){ assert(*queue!=NULL); Node *head = (*queue)->head; Node *tmp; while (head) { tmp = head; head = head->next; // printf(\"free data:%d\\n\",tmp->data); free(tmp); } (*queue)->head = NULL; (*queue)->size = 0; *queue = NULL; free(*queue); } // 打印队列 void dump(Queue *queue){ assert(queue!=NULL); if (queue->sizehead; printf(\"dump begin\\n\"); while (head) { printf(\"%d \",head->data); head = head->next; } printf(\"\\ndump end\\n\"); } int main(int argc, const char * argv[]) { Queue *queue = create(); for (int i=0; idata = i; enqueue(queue,node); } dump(queue); Node *node = dequeue(queue); if(node){ printf(\"pop success data:%d\\n\",node->data); free(node); }else{ printf(\"pop failed\\n\"); } dump(queue); cleanup(&queue); return 0; } By zhjzjnb，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-06-13 11:35:59 "},"swift/Basics.html":{"url":"swift/Basics.html","title":"1-基础","keywords":"","body":" 函数别名 typealias Callback = ()->Void 类似c语言 typedef int (*func) (int param); Any和AnyObject区别 AnyObject后缀带了Object，说明是任何类对象的实例 Any是任意类型范围，包含AnyObject 闭包，闭包有参数又不想使用,用_ in 忽略，不然会编译出错 By zhjzjnb，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-06-13 11:35:59 "}}